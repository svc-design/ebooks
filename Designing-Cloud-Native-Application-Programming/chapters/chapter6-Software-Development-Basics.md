# 编程语言的基本特性

软件开发最基本、最通用的知识包括：

- 编程语言：编程语言是用来编写软件的工具。最基本的编程语言是汇编语言，它可以直接操作计算机硬件。高级编程语言提供了更高的抽象度，可以让开发人员更容易地编写软件。常用的高级编程语言包括 C、C++、Java、Python 和 JavaScript。
- 数据结构和算法：数据结构和算法是软件开发的理论基础。数据结构用于存储和组织数据，算法用于处理数据。熟悉数据结构和算法可以帮助开发人员设计更高效、更可靠的软件。
- 操作系统：操作系统是控制计算机硬件和软件的软件。开发人员需要了解操作系统的基本原理，才能在操作系统之上开发软件。
- 软件开发流程：软件开发流程是开发软件的一种系统化方法。常用的软件开发流程包括瀑布模型、敏捷开发和迭代开发。
- 软件测试：软件测试是确保软件正确运行的一种方法。软件测试包括单元测试、集成测试、系统测试和验收测试。

从汇编到系统语言 C 到 java python js 等高级语言，从单片机版应用到运行在操作系统之上的应用，这些知识都是通用的。开发人员可以根据自己的需求和目标选择合适的知识来学习。

以下是一些参考建议：

- 对于初学者，可以先从学习高级编程语言开始。Java、Python 和 JavaScript 都是比较容易上手的语言。
- 对于有一定基础的开发人员，可以学习数据结构和算法，以及操作系统等更深入的知识。
- 对于想要从事系统软件开发的开发人员，需要学习汇编语言和操作系统等知识。
- 对于想要从事移动应用开发的开发人员，需要学习 Android 和 iOS 等平台的开发语言和框架。
- 对于想要从事 WEB 应用开发的开发人员，需要掌握 HTML、CSS 和 JavaScript，常用的 Web 开发框架，还包括数据库、服务器、安全等基础知识。

无论什么编程语言，它们都具有以下最共性的基础语法和结构：

- 变量: 变量是用于存储数据的一种数据类型。变量必须声明，声明时需要指定变量类型和名称。变量类型可以是基本数据类型，也可以是自定义数据类型。
- 运算符： 运算符用于对数据进行操作。运算符可以是算术运算符、关系运算符、逻辑运算符等。
- 语句： 语句是编程语言的基本单位。语句用于表达一个完整的操作。语句可以是赋值语句、输入语句、输出语句、控制流语句等。
- 控制流: 控制流用于控制程序执行的顺序。控制流可以是条件语句、循环语句等。
- 函数: 函数用于封装代码，并可以重复使用。函数由函数声明、函数定义和函数调用组成。

这些基础语法和结构是编程语言的基本要素。它们是编写任何编程语言程序的基础。除了这些基础语法和结构之外，不同的编程语言还可能具有其他的语法和结构。例如，面向对象编程语言具有类、对象、方法等语法和结构；函数式编程语言具有函数、闭包等语法和结构。

## 图灵完备

图灵完备的语言是指能够模拟任何图灵机的语言。图灵机是一种抽象的计算机模型，可以模拟任何可以被计算的函数。

图灵完备的语言具有以下特点：

- 可以表达任意复杂的算法。
- 可以模拟任何计算机程序。
- 可以生成任何可计算的输出。

几乎所有常用的编程语言都是图灵完备的，包括 C、C++、Java、Python、JavaScript 等。

- 汇编语言：汇编语言是直接对计算机硬件进行操作的语言。它是最基本的图灵完备语言。
- 高级语言：高级语言是面向人类编写的语言。几乎所有常用的高级语言都是图灵完备的。
- 脚本语言：脚本语言是一种快速开发应用程序的语言。有些脚本语言也是图灵完备的。

图灵完备性是编程语言的重要特性。它意味着，使用图灵完备的语言，可以编写任何可以被计算的程序。 图灵完备性还意味着，图灵完备的语言之间是等价的。也就是说，使用一种图灵完备的语言编写的程序，可以用另一种图灵完备的语言来模拟。

作为一门图灵完备的语言的基础语法包含总结如下：

## 基础类型

- 赋值语句：允许将值分配给变量或数据结构。
- 数字类型：支持整数和浮点数，可能有不同的精度。
- 布尔类型：包括真和假两个值，通常用于逻辑判断。
- 字符：用于表示单个字符，通常采用字符编码。
- 字符串：表示文本数据的序列，通常由字符组成。
- 数组：一种数据结构，用于存储相同类型的元素的有序集合。
- 动态数组：可以动态增长或缩小大小的数组，通常由编程语言的内置功能或库支持。
- 哈希表：一种键值对存储结构，允许通过键查找值，通常具有快速查找速度。

## 复合类型

- 元组：有序的元素集合，可以包含不同类型的数据。
- 结构体：自定义的数据类型，可以包含不同字段。
- 枚举：一种数据类型，包括一组命名的值。

## 控制流

分支：用于根据条件选择不同的代码路径。

循环：用于重复执行代码块，通常在特定条件下终止。

函数：用于封装可重用的代码块。

闭包：允许函数捕获并访问其周围范围的变量(函数式编程概念)。

## 代码组织

- 类：属于面向对象编程（OOP）范畴，它是一种用于定义自定义数据类型的概念，包括对象的属性和方法。类用于封装数据和行为，具有与对象和类相关的特性(面对对象编程的概念，面向过程的语言也可以模拟部分特性)。
- 库：属于软件开发和编程工具的范畴。库是一组可重用的代码、函数、数据结构和类的集合，用于提供通用功能，以便在不同的应用程序中重复使用。库可以涵盖多个编程领域，如标准库、第三方库等。
- 模块：模块是一种组织和封装代码的方式，通常属于编程语言或开发环境的范畴。模块可以包含变量、函数、类、结构体等代码元素，以提高代码的可维护性和可重用性。模块用于组织和划分代码，并有助于避免命名冲突。
- 接口：接口是编程中的概念，属于面向对象编程和编程规范的范畴。接口定义了对象应该具备的行为规范，而不涉及具体的实现。接口用于定义方法的签名，实现某个接口的类或结构体必须提供这些方法的具体实现。

## 常用语言语法特性对比

以 C、 Python 、 Go 、 Rust 、 JavaScript 为例，使用表格

| 基础类别 | 语法特性 | C | Python | Go | Rust | JavaScript（前端） | JavaScript（后端） |
|:----|:----|:----|:----|:----|:----|:----|:----|
| 基础类型 | 整型 | int | int | i32 | i32 | number | number |
| 基础类型 | 浮点型 | float | float | f32 | f64 | number | number |
| 基础类型 | 字符 | char | str | char | char | string | string |
| 基础类型 | 字符串型 | char\* | str | &str | String | string | string |
| 基础类型 | 指针型 | void\* | int | \* | \* | any | any |
| 基础类型 | 布尔型 | bool | bool | bool | bool | boolean | boolean |
| 复合类型｜数组 | int[] | list | []int | i32 | array | array |
| 复合类型｜字典 | dict | dict | mapstringstring | HashMap<String, String> | object | object |
| 复合类型｜结构体/对象 | struct | class | struct | Struct | class | class |
| 复合类型｜联合型 | union | enum | union | Union | enum | enum |
| 复合类型｜枚举 | enum | enum | enum | Enum | enum | enum |
| 表达式 | 算术运算符 | +, -, \*, /, % | +, -, \*, /, % | +, -, \*, /, % | +, -, \*, /, % | +, -, \*, /, % | +, -, \*, /, % |
| 表达式 | 关系运算符 | ==, !=, <, >, <=, >= | ==, !=, <, >, <=, >= | ==, !=, <, >, <=, >= | ==, !=, <, >, <=, >= | ==, !=, <, >, <=, >= | ==, !=, <, >, <=, >= |
| 表达式 | 逻辑运算符 | &&, &#124;&#124; | and, or | &&, &#124;&#124; | &&, &#124;&#124; | &&, &#124;&#124; | &&, &#124;&#124; |
| 表达式 | 赋值运算符 | = | = | = | = | = | = |
| 表达式 | 位运算符 | &, &#124;, ^, ~, <<, >> | &, &#124;, ^, ~, <<, >> | &, &#124;, ^, ~, <<, >> | &, &#124;, ^, ~, <<, >> | &, &#124;, ^, ~, <<, >> | &, &#124;, ^, ~, <<, >> |
| 控制流 | 分支语句 | if, else | if, else | if, else | if, else | if, else | if, else |
| 控制流 | 循环语句 | for, while | for, while | for, while | for, while | for, while | for, while |
| 控制流 | 函数调用 | 函数调用 | 函数调用 | 函数调用 | 函数调用 | 函数调用 | 函数调用 |
| 代码组织 | 结构 | 函数、全局变量、#define | 函数、模块、类 | 函数、包、接口 | 函数、模块、结构体 | 函数、对象、类 | 函数、模块、类 |
| 内存管理 | 方式 | 程序员管理 | 垃圾回收 | 程序员管理 | 程序员管理 | 垃圾回收 | 垃圾回收 |
| 类型 | 强/弱 | 强 | 弱 | 强 | 强 | 弱 | 弱 |
| 语言特性 | 指针 | 支持 | 支持 | 支持 | 支持 | 支持 |
| 语言特性 | 静态/动态 | 静态 | 动态 | 静态 | 静态 | 动态 | 动态 |


# 数据结构与算法

## 线性数据结构

- 数组：数组是一种线性表，可以存储相同类型的多个元素，具有固定的长度。
- 链表：链表是一种线性表，每个元素都有指向下一个元素的指针，具有可变的长度。
- 栈：栈是一种先进后出的数据结构，只能在栈顶进行插入和删除操作。
- 队列：队列是一种先进先出的数据结构，只能在队头进行插入操作，只能在队尾进行删除操作。

## 非线性数据结构

- 树：树是一种非线性表，由节点和边组成，每个节点最多有两个子节点。
- 图：图是一种非线性表，由顶点和边组成，任意两个顶点之间可以有一条边。

## 算法

- 排序：排序是一种将数据按照特定顺序进行排列的过程。常见的排序算法有冒泡排序、选择排序、插入排序、归并排序、快速排序等。
- 查找：查找是一种在数据集中找到满足特定条件的元素的过程。常见的查找算法有顺序查找、二分查找等。
- 图算法：图算法是针对图的数据结构设计的算法。常见的图算法有最短路径算法、最小生成树算法、拓扑排序等。
- 动态规划：动态规划是一种分治思想的算法，将一个复杂的问题分解为多个子问题，然后递归地求解子问题，最后将子问题的答案合并得到原问题的答案。
- 分治算法：分治算法是一种将一个问题分解为多个子问题，然后递归地求解子问题，最后将子问题的答案合并得到原问题的答案。

### 适用场景

#### 特点

数组：适用于存储相同类型的多个元素，具有固定的长度。

栈：适用于存储需要先进后出的数据，具有固定的长度。

链表：适用于存储需要动态添加或删除元素的数据，具有可变的长度。

队列：适用于存储需要先进先出的数据，具有可变的长度。

树：适用于存储具有层次结构的数据，具有可变的长度。

图：适用于存储具有连接关系的数据，具有可变的长度

#### 数据结构

- 数组：常用于存储相同类型的多个元素，例如学生成绩、商品价格等。
- 链表：常用于存储需要动态添加或删除元素的数据，例如购物车、队列等。
- 栈：常用于存储需要先进后出的数据，例如浏览器的历史记录、函数调用栈等。
- 队列：常用于存储需要先进先出的数据，例如打印机的打印队列、生产者消费者模型等。
- 树：常用于存储具有层次结构的数据，例如文件系统、目录结构、组织结构等。
- 图：常用于存储具有连接关系的数据，例如交通网络、社交网络、供应链等。

#### 算法

- 排序：常用于对数据进行排序，例如将学生成绩从高到低排序、将商品价格从低到高排序等。
- 查找：常用于在数据集中找到满足特定条件的元素，例如查找学生成绩排名第一的学生、查找商品库存量最少的商品等。
- 图算法：常用于解决图中的问题，例如计算最短路径、找出最小生成树等。
- 动态规划：常用于解决具有重复子问题的问题，例如求斐波那契数列、求最长上升子序列等。
- 分治算法：常用于将一个复杂的问题分解为多个子问题，然后递归地求解子问题，最后将子问题的答案合并得到原问题的答案。

| 数据结构/算法 | 常见使用场景 | 使用范围 | 算法复杂度 |
|:----|:----|:----|:----|
| 数组 | 存储相同类型的多个元素 | 固定长度 | O(1) |
| 链表 | 存储需要动态添加或删除元素的数据 | 可变长度 | O(1) |
| 栈 | 存储需要先进后出的数据 | 固定长度 | O(1) |
| 队列 | 存储需要先进先出的数据 | 可变长度 | O(1) |
| 树 | 存储具有层次结构的数据 | 可变长度 | O(log n) |
| 图 | 存储具有连接关系的数据 | 可变长度 | O(n) |
| 排序 | 对数据进行排序 | 一般 | O(n log n) |
| 查找 | 在数据集中找到满足特定条件的元素 | 一般 | O(n) |
| 图算法 | 解决图中的问题 | 图 | O(n^2) |
| 动态规划 | 解决具有重复子问题的问题 | 一般 | O(n) |
| 分治算法 | 将一个复杂的问题分解为多个子问题 | 一般 | O(n log n) |


## 常用语言示例

以 C、 Python 、 Go 、 Rust 、 JavaScript 为例

| 类别 | C | Python | Go | Rust | JavaScript |
|:----|:----|:----|:----|:----|:----|
| 数组 | stdlib.h / int a10; | typing / list | stdlib / []int | std / Vec<T> | stdlib / Array.from() |
| 链表 | stdlib.h / struct node { int data; struct node \*next; }; | collections / collections.deque | stdlib / \*linkedlist.List | std / LinkedList<T> | linkedlist / LinkedList() |
| 栈 | stdlib.h / struct stack { int top; int data10; }; | collections / collections.deque | stdlib / \*stack.Stack | std / Stack<T> | stack / Stack() |
| 队列 | stdlib.h / struct queue { int front; int rear; int data10; }; | collections / collections.deque | stdlib / \*queue.Queue | std / Queue<T> | queue / Queue() |
| 树 | stdlib.h / struct tree { int data; struct tree _left; struct tree_ right; }; | collections / collections.defaultdict | stdlib / \*tree.Tree | std / Tree<T> | tree / Tree() |
| 图 | stdlib.h / struct graph { int vertex\_num; int edge\_num; struct edge \*edges; }; | networkx / import networkx as nx | stdlib / \*graph.Graph | std / Graph<T> | graph / import graphlib as gl |
| 排序 | stdlib.h / qsort(arr, n, sizeof(int), cmp); | typing / sorted() | sort / sort.Slice() | std / sort::sort() | stdlib / Array.sort() |
| 查找 | stdlib.h / binary\_search(arr, n, x); | typing / bisect.bisect\_left() | sort / sort.Search() | std / std::search() | stdlib / Array.find() |
| 图算法 | stdlib.h / dfs(graph, start\_vertex); | networkx / nx.dfs(graph, start\_vertex) | graph / graph.DFS() | std / graph::dfs() | graph / gl.dfs(graph, start\_vertex) |
| 动态规划 | stdlib.h / dpn = max(dpn-1, dpn-2); | tabulation / import tabulation as tb | std / dpn = max(dpn-1, dpn-2); | std / dpn = max(dpn-1, dpn-2); | std / dpn = max(dpn-1, dpn-2); |
| 分治算法 | stdlib.h / merge\_sort(arr, start, end); | divide\_and\_conquer / import divide\_and\_conquer as dc | sort / sort.Slice() | std / sort::sort() | stdlib / Array.sort() |


说明

表格中标记为 stdlib.h 的表示标准库头文件，需要包含到程序中。

表格中标记为 import 的表示第三方库，需要先安装。

表格中标记为 typing 的表示 Python 的类型注解，可以不用。

# 操作系统

## 内核

操作系统内核是控制计算机硬件和软件的软件。它为应用程序提供了一个抽象的平台，让应用程序可以不必直接与硬件交互。

一个操作系统内核最核心的部分是：

- 进程管理：负责创建、调度和终止进程。
- 内存管理：负责分配和回收内存。
- 设备驱动：负责管理设备硬件。
- 文件系统：负责存储和管理文件。

操作系统内核为运行在它之上的应用提供了以下封装：

- 虚拟内存：应用程序可以使用虚拟内存，而不用担心实际内存的大小。
- 进程间通信：应用程序可以通过各种方式进行通信，例如消息传递、共享内存和管道。
- 文件系统：应用程序可以访问文件系统中的文件。
- 设备驱动：应用程序可以通过操作系统内核访问设备硬件。

## 内核态和用户态

内核态和用户态是操作系统中两个不同的运行模式。内核态是操作系统内核运行的模式，用户态是应用程序运行的模式。

在内核态下，应用程序可以直接访问硬件资源，而不需要经过操作系统的检查。在用户态下，应用程序只能访问操作系统提供的接口。

内核态和用户态之间的切换是由操作系统来控制的。当应用程序需要访问硬件资源时，它会进入内核态。当应用程序完成对硬件资源的访问后，它会回到用户态。

内核态和用户态的区别如下：

特征	内核态	用户态

权限	最高权限	受限权限

可访问资源	所有资源	操作系统提供的资源

代码执行	直接执行	通过系统调用执行

应用程序	操作系统内核	用户应用程序

内核态和用户态的区分是为了保护操作系统和应用程序的安全。在内核态下，应用程序可以直接访问硬件资源，这可能会导致系统崩溃或数据损坏。为了防止这种情况发生，操作系统将内核态和用户态进行了隔离。

## 内存管理

计算机启动时，处于实模式。实模式下，计算机的地址空间只有 1 MB，并且所有的内存都是直接可访问的。以X86指令集的CPU为例，在实模式下，BIOS 会加载内核到内存的 0x0000:0x7C00 处。内核是一个特殊的程序，它负责启动操作系统。

加载完毕内核后，BIOS会把对硬件的控制健全交给内核，内核会通过 lgdt 和 lidt 指令来切换到保护模式，从而完成实模式到保护模式的切换，在保护模式下，计算机的地址空间可以大于 1 MB，并且内存被分为两部分：内核空间和应用空间。

### 内核空间

内核空间是操作系统运行的区域，应用程序无法直接访问内核空间。内核空间中的内存由操作系统管理，应用程序无法直接分配或释放内核空间中的内存。

物理地址是内存中一个存储单元的实际地址，是内核直接访问和管理的空间

### 用户空间

- 虚拟地址是指进程视角看到的操作为期提供的内存地址。在保护模式下，每个进程都有自己的虚拟地址空间。虚拟地址空间是通过分页来实现的。
- 分页是将虚拟内存划分为大小相同的页面，每个页面大小通常为 4 KB 或 8 KB。每个进程都有
自己的页表，用于将虚拟地址映射到物理地址。当进程需要访问一个页面时，操作系统会首先检查该页面是否在物理内存中。如果在物理内存中，则操作系统将直接将虚拟地址转换为物理地址，并将数据返回给进程。如果不在物理内存中，则操作系统会将该页面从磁盘中加载到物理内存中。
- 交换是将进程的页面从内存中换出到磁盘上，以释放内存空间。交换通常用于以下情况：
当进程的页面数超过物理内存的大小时。
当进程的页面长时间没有被访问时。

## 堆和栈

堆和栈都是用户空间的内存。

- 堆是用于动态内存分配的区域，应用程序可以通过 malloc() 等 API 申请堆内存。堆内存的大小是可变的，可以随时增加或减少。应用程序必须使用 free() 等 API 来释放不再使用的堆内存。
- 栈是用于线程私有数据的区域，应用程序可以通过 push() 和 pop() 等指令操作栈。栈内存用于存储函数调用时使用的参数、返回地址和局部变量。栈内存是按 LIFO（后进先出）顺序分配和释放的。

## buffer和cache

- buffer 是指内存中的一个区域，用于存储临时数据。 buffer 可以位于内核空间，用于存储操作系统使用的内存数据，例如文件数据、网络数据和设备数据。buffer 也可以位于用户空间，用于存储应用程序使用的内存数据，例如图像数据、音频数据和文本数据。buffer 是指内存中的一个区域，用于存储临时数据。

```
* 提高 I/O 性能：buffer 可以缓冲 I/O 操作的数据，从而减少 I/O 操作的次数，提高 I/O 性能。
* 提高 CPU 性能：buffer 可以缓冲 CPU 需要的数据，从而减少 CPU 访问内存的次数，提高 CPU 性能。cache 是指内存中的一个区域，用于存放经常访问的数据。cache 可以提高数据读取的速度，从而提高系统性能。cache 可以位于内核空间，用于存储操作系统经常访问的数据，例如文件数据和设备数据。cache 也可以位于用户空间，用于存储应用程序经常访问的数据，例如图像数据和音频数据。buffer 和 cache 都是用来提高系统性能的技术。buffer 用于存储临时数据，而 cache 用于存储经常访问的数据。buffer 可以用于各种目的，而 cache 通常用于提高数据访问的速度。
```

在 Linux 64 位内核中，堆和栈都位于用户空间，地址从高地址向低地址增长。堆的起始地址由操作系统分配，在应用程序运行时可以动态增长。栈的起始地址由操作系统分配，在函数调用时分配，在函数返回时释放。

也有例外情况。例如，应用程序可以通过 mmap() 系统调用将内核空间的内存映射到用户空间。在这种情况下，应用程序可以直接访问内核空间中的内存，包括 buffer 和 cache

## 进程，线程，协程

- 进程：进程是操作系统中资源分配的最小单位，每个进程都有自己的独立的内存空间、代码空间、数据空间、堆栈空间等。进程的特点是独立性强，但切换效率低。
- 线程：线程是进程内的一个执行实体，每个线程都有自己的堆栈空间，但共享进程的内存空间、代码空间等。线程的特点是切换效率高，但独立性弱。
- 协程：协程是轻量级的线程，每个协程都有自己的堆栈空间和局部变量，但共享进程的内存空间、代码空间等。协程的特点是切换效率高，且可以实现并发执行。
- 进程间通信：进程间通信（IPC）是指两个或多个进程之间相互发送数据或信号的过程。常见的IPC方式包括管道、消息队列、共享内存等。
- 多线程编程：多线程编程是指在一个进程中同时运行多个线程的过程。多线程编程可以提高程序的并发性和响应速度。

## Linux IO

Linux IO 是 Linux 操作系统中用于处理输入输出请求的机制。Linux IO 主要包括以下几个部分：

- 设备驱动程序：设备驱动程序是用于与特定设备进行通信的软件。设备驱动程序将设备的硬件接口转换为操作系统可以理解的接口。
- 内核空间 IO 子系统：内核空间 IO 子系统是操作系统用于处理 IO 请求的核心组件。内核空间 IO 子系统负责将 IO 请求发送到设备驱动程序，并将设备驱动程序的响应返回给应用程序。
- 用户空间 IO 库：用户空间 IO 库是用于简化应用程序对 IO 的访问的软件。用户空间 IO 库将应用程序的 IO 请求转换为内核空间 IO 子系统可以理解的接口。

Linux IO 主要有以下几种模型：

- 阻塞 IO：阻塞 IO 是指应用程序在发出 IO 请求后会被阻塞，直到 IO 请求完成。阻塞 IO 模型简单易用，但会导致应用程序的响应性下降。
- 非阻塞 IO：非阻塞 IO 是指应用程序在发出 IO 请求后不会被阻塞，而是会立即返回。应用程序可以通过轮询或信号来检测 IO 请求是否完成。非阻塞 IO 模型可以提高应用程序的响应性，但需要应用程序自己来处理 IO 请求的完成情况。
- 异步 IO：异步 IO 是指应用程序在发出 IO 请求后会立即返回，IO 请求的完成由操作系统通知应用程序。异步 IO 模型可以最大限度地提高应用程序的响应性，但需要应用程序自己来处理 IO 请求的完成情况。

Linux IO 还支持以下几种优化技术：

- 缓存：缓存可以提高 IO 的性能。操作系统可以将经常访问的数据缓存在内存中，从而减少对设备的访问次数。
- 预读：预读可以提高 IO 的性能。操作系统可以预先读取应用程序可能需要的数据，从而减少应用程序的等待时间。
- 集合 IO：集合 IO 可以提高 IO 的性能。操作系统可以将多个 IO 请求合并成一个请求，从而减少对设备的访问次数。

从应用开发的视角，Linux IO 库可以分为以下几类：

- 文件 IO 库：用于操作文件的库，例如 open()、read()、write()、close() 等系统调用。
- 网络 IO 库：用于操作网络的库，例如 socket()、connect()、send()、recv() 等系统调用。
- 设备 IO 库：用于操作设备的库，例如 ioctl()、mmap()、munmap() 等系统调用。

以下是一些常用的 Linux IO 库：

- 标准 C 库：标准 C 库提供了基本的 IO 操作，例如 open()、read()、write()、close() 等系统调用。
- POSIX 库：POSIX 库提供了更高级的 IO 操作，例如 fopen()、fread()、fwrite()、fclose() 等系统调用。
- GNU 库：GNU 库提供了更强大的 IO 操作，例如 gopen()、gread()、gwrite()、gclose() 等系统调用。
- 第三方库：第三方库提供了各种各样的 IO 操作，例如 libcurl()、libuv()、libevent() 等库。

以 C、 Python 、 Go 、 Rust 、 JavaScript 为例

| 类别 | C | Python | Go | Rust | JavaScript |
|:----|:----|:----|:----|:----|:----|
| 进程 | fork | multiprocessing / multiprocessing.Process() | os / os.Fork() | std::process::Fork() | child\_process / child\_process.fork() |
| 线程 | pthread\_create | threading / threading.Thread() | sync / sync.NewThread() | std::thread::spawn() | threads / threads.spawn() |
| 协程 | goroutine | asyncio / asyncio.get\_event\_loop().run\_until\_complete() | go / go func() | std::future::spawn() | async / async function() |
| 消息 | queue | queue / queue.Queue() | sync / sync.NewWaitGroup() | std::sync::mpsc::channel() | queue / queue() |
| 共享内存 | shmget | multiprocessing / multiprocessing.shared\_memory.SharedMemory() | sync / sync.Map() | std::sync::mpsc::shared\_queue() | shared / shared() |
| 管道 | pipe | multiprocessing / multiprocessing.Pipe() | os / os.Pipe() | std::os::unix::net::pipe() | stream / stream() |
| 同步IO | read | io / io.open() | io / io.Read() | std::io::Read() | fs / fs.readFile() |
| 异步IO | asyncio.open | asyncio / asyncio.open() | io / io.Read() | std::io::Read() | fs / fs.readFile() |
| 多路复用 | select | select | select / std::net::poll() / net / net.select() | select / select / epoll.epoll() / std::net::epoll() / net / net.epoll() |
| 高性能多路复用 | epoll / epoll / epoll / std::net::epoll() / net / net.epoll() | epoll / epoll / epoll / std::net::epoll() / net / net.epoll() |


**说明**

- 表格中标记为 stdlib.h 的表示标准库头文件，需要包含到程序中。
- 表格中标记为 import 的表示第三方库，需要先安装。
- 表格中标记为 typing 的表示 Python 的类型注解，可以不用。

**附加说明**

- `select()` 和 `epoll()` 是两种不同的多路复用方式，`select()` 是传统的多路复用方式，效率较低；`epoll()` 是高性能的多路复用方式，效率较高。
- 表格中 `select()` 和 `epoll()` 的语法分别使用了两种展示方式，一种是使用 `:` 来分隔参数，另一种是使用 `/` 来分隔参数。这两种方式都是正确的，可以根据自己的喜好选择
