# 编程语言的基本特性

软件开发最基本、最通用的知识包括：

* 编程语言：编程语言是用来编写软件的工具。最基本的编程语言是汇编语言，它可以直接操作计算机硬件。高级编程语言提供了更高的抽象度，可以让开发人员更容易地编写软件。常用的高级编程语言包括 C、C++、Java、Python 和 JavaScript。
* 数据结构和算法：数据结构和算法是软件开发的理论基础。数据结构用于存储和组织数据，算法用于处理数据。熟悉数据结构和算法可以帮助开发人员设计更高效、更可靠的软件。
* 操作系统：操作系统是控制计算机硬件和软件的软件。开发人员需要了解操作系统的基本原理，才能在操作系统之上开发软件。
* 软件开发流程：软件开发流程是开发软件的一种系统化方法。常用的软件开发流程包括瀑布模型、敏捷开发和迭代开发。
* 软件测试：软件测试是确保软件正确运行的一种方法。软件测试包括单元测试、集成测试、系统测试和验收测试。

从汇编到系统语言 C 到 java python js 等高级语言，从单片机版应用到运行在操作系统之上的应用，这些知识都是通用的。开发人员可以根据自己的需求和目标选择合适的知识来学习。

以下是一些参考建议：

* 对于初学者，可以先从学习高级编程语言开始。Java、Python 和 JavaScript 都是比较容易上手的语言。
* 对于有一定基础的开发人员，可以学习数据结构和算法，以及操作系统等更深入的知识。
* 对于想要从事系统软件开发的开发人员，需要学习汇编语言和操作系统等知识。
* 对于想要从事移动应用开发的开发人员，需要学习 Android 和 iOS 等平台的开发语言和框架。
* 对于想要从事 WEB 应用开发的开发人员，需要掌握 HTML、CSS 和 JavaScript，常用的 Web 开发框架，还包括数据库、服务器、安全等基础知识。

无论什么的编程语言，只要

## 基础类型

* 赋值语句：允许将值分配给变量或数据结构。
* 数字类型：支持整数和浮点数，可能有不同的精度。
* 布尔类型：包括真和假两个值，通常用于逻辑判断。
* 字符：用于表示单个字符，通常采用字符编码。
* 字符串：表示文本数据的序列，通常由字符组成。
* 数组：一种数据结构，用于存储相同类型的元素的有序集合。
* 动态数组：可以动态增长或缩小大小的数组，通常由编程语言的内置功能或库支持。
* 哈希表：一种键值对存储结构，允许通过键查找值，通常具有快速查找速度。

## 复合类型

* 元组：有序的元素集合，可以包含不同类型的数据。
* 结构体：自定义的数据类型，可以包含不同字段。
* 枚举：一种数据类型，包括一组命名的值。

## 控制流

分支：用于根据条件选择不同的代码路径。
循环：用于重复执行代码块，通常在特定条件下终止。
函数：用于封装可重用的代码块。
闭包：允许函数捕获并访问其周围范围的变量。

## 代码组织

* 类：属于面向对象编程（OOP）范畴，它是一种用于定义自定义数据类型的概念，包括对象的属性和方法。类用于封装数据和行为，具有与对象和类相关的特性。
* 库：属于软件开发和编程工具的范畴。库是一组可重用的代码、函数、数据结构和类的集合，用于提供通用功能，以便在不同的应用程序中重复使用。库可以涵盖多个编程领域，如标准库、第三方库等。
* 模块：模块是一种组织和封装代码的方式，通常属于编程语言或开发环境的范畴。模块可以包含变量、函数、类、结构体等代码元素，以提高代码的可维护性和可重用性。模块用于组织和划分代码，并有助于避免命名冲突。
* 接口：接口是编程中的概念，属于面向对象编程和编程规范的范畴。接口定义了对象应该具备的行为规范，而不涉及具体的实现。接口用于定义方法的签名，实现某个接口的类或结构体必须提供这些方法的具体实现。

## 常用语言语法特性对比

以 C、 Python 、 Go 、 Rust 、 JavaScript 为例，使用表格

| 基础类别 | 语法特性 | C | Python | Go | Rust | JavaScript（前端） | JavaScript（后端） |
|---|---|---|---|---|---|---|---|
| 基础类型 | 整型 | int | int | i32 | i32 | number | number |
| 基础类型 | 浮点型 | float | float | f32 | f64 | number | number |
| 基础类型 | 字符 | char | str | char | char | string | string |
| 基础类型 | 字符串型 | char* | str | &str | String | string | string |
| 基础类型 | 指针型 | void* | int | * | * | any | any |
| 基础类型 |布尔型 | bool | bool | bool | bool | boolean | boolean |
| 复合类型｜数组 | int[] | list | []int | [i32] | array | array |
| 复合类型｜字典 | dict | dict | map[string]string | HashMap<String, String> | object | object |
| 复合类型｜结构体/对象 | struct | class | struct | Struct | class | class |
| 复合类型｜联合型 | union | enum | union | Union | enum | enum |
| 复合类型｜枚举 | enum | enum | enum | Enum | enum | enum |
| 表达式 | 算术运算符 | +, -, *, /, % | +, -, *, /, % | +, -, *, /, % | +, -, *, /, % | +, -, *, /, % | +, -, *, /, % |
| 表达式 | 关系运算符 | ==, !=, <, >, <=, >= | ==, !=, <, >, <=, >= | ==, !=, <, >, <=, >= | ==, !=, <, >, <=, >= | ==, !=, <, >, <=, >= | ==, !=, <, >, <=, >= |
| 表达式 | 逻辑运算符 | &&, \|\| | and, or | &&, \|\| | &&, \|\| | &&, \|\| | &&, \|\| |
| 表达式 | 赋值运算符 | = | = | = | = | = | = |
| 表达式 | 位运算符 | &, \|, ^, ~, <<, >> | &, \|, ^, ~, <<, >> | &, \|, ^, ~, <<, >> | &, \|, ^, ~, <<, >> | &, \|, ^, ~, <<, >> | &, \|, ^, ~, <<, >> |
| 控制流 | 分支语句 | if, else | if, else | if, else | if, else | if, else | if, else |
| 控制流 | 循环语句 | for, while | for, while | for, while | for, while | for, while | for, while |
| 控制流 | 函数调用 | 函数调用 | 函数调用 | 函数调用 | 函数调用 | 函数调用 | 函数调用 |
| 代码组织 | 结构 | 函数、全局变量、#define | 函数、模块、类 | 函数、包、接口 | 函数、模块、结构体 | 函数、对象、类 | 函数、模块、类 |
| 内存管理 | 方式 | 程序员管理 | 垃圾回收 | 程序员管理 | 程序员管理 | 垃圾回收 | 垃圾回收 |
| 类型 | 强/弱 | 强 | 弱 | 强 | 强 | 弱 | 弱 |
| 语言特性 | 指针 | 支持 | 支持 | 支持 | 支持 | 支持 |
| 语言特性 |静态/动态 | 静态 | 动态 | 静态 | 静态 | 动态 | 动态 |

# 数据结构与算法

## 线性数据结构

* 数组：数组是一种线性表，可以存储相同类型的多个元素，具有固定的长度。
* 链表：链表是一种线性表，每个元素都有指向下一个元素的指针，具有可变的长度。
* 栈：栈是一种先进后出的数据结构，只能在栈顶进行插入和删除操作。
* 队列：队列是一种先进先出的数据结构，只能在队头进行插入操作，只能在队尾进行删除操作。

## 非线性数据结构

* 树：树是一种非线性表，由节点和边组成，每个节点最多有两个子节点。
* 图：图是一种非线性表，由顶点和边组成，任意两个顶点之间可以有一条边。

## 算法

* 排序：排序是一种将数据按照特定顺序进行排列的过程。常见的排序算法有冒泡排序、选择排序、插入排序、归并排序、快速排序等。
* 查找：查找是一种在数据集中找到满足特定条件的元素的过程。常见的查找算法有顺序查找、二分查找等。
* 图算法：图算法是针对图的数据结构设计的算法。常见的图算法有最短路径算法、最小生成树算法、拓扑排序等。
* 动态规划：动态规划是一种分治思想的算法，将一个复杂的问题分解为多个子问题，然后递归地求解子问题，最后将子问题的答案合并得到原问题的答案。
* 分治算法：分治算法是一种将一个问题分解为多个子问题，然后递归地求解子问题，最后将子问题的答案合并得到原问题的答案。

### 适用场景

#### 特点

数组：适用于存储相同类型的多个元素，具有固定的长度。
栈：适用于存储需要先进后出的数据，具有固定的长度。
链表：适用于存储需要动态添加或删除元素的数据，具有可变的长度。
队列：适用于存储需要先进先出的数据，具有可变的长度。
树：适用于存储具有层次结构的数据，具有可变的长度。
图：适用于存储具有连接关系的数据，具有可变的长度

#### 数据结构

* 数组：常用于存储相同类型的多个元素，例如学生成绩、商品价格等。
* 链表：常用于存储需要动态添加或删除元素的数据，例如购物车、队列等。
* 栈：常用于存储需要先进后出的数据，例如浏览器的历史记录、函数调用栈等。
* 队列：常用于存储需要先进先出的数据，例如打印机的打印队列、生产者消费者模型等。
* 树：常用于存储具有层次结构的数据，例如文件系统、目录结构、组织结构等。
* 图：常用于存储具有连接关系的数据，例如交通网络、社交网络、供应链等。

#### 算法

* 排序：常用于对数据进行排序，例如将学生成绩从高到低排序、将商品价格从低到高排序等。
* 查找：常用于在数据集中找到满足特定条件的元素，例如查找学生成绩排名第一的学生、查找商品库存量最少的商品等。
* 图算法：常用于解决图中的问题，例如计算最短路径、找出最小生成树等。
* 动态规划：常用于解决具有重复子问题的问题，例如求斐波那契数列、求最长上升子序列等。
* 分治算法：常用于将一个复杂的问题分解为多个子问题，然后递归地求解子问题，最后将子问题的答案合并得到原问题的答案。


| 数据结构/算法 | 常见使用场景 | 使用范围 | 算法复杂度 |
|---|---|---|---|
| 数组 | 存储相同类型的多个元素 | 固定长度 | O(1) |
| 链表 | 存储需要动态添加或删除元素的数据 | 可变长度 | O(1) |
| 栈 | 存储需要先进后出的数据 | 固定长度 | O(1) |
| 队列 | 存储需要先进先出的数据 | 可变长度 | O(1) |
| 树 | 存储具有层次结构的数据 | 可变长度 | O(log n) |
| 图 | 存储具有连接关系的数据 | 可变长度 | O(n) |
| 排序 | 对数据进行排序 | 一般 | O(n log n) |
| 查找 | 在数据集中找到满足特定条件的元素 | 一般 | O(n) |
| 图算法 | 解决图中的问题 | 图 | O(n^2) |
| 动态规划 | 解决具有重复子问题的问题 | 一般 | O(n) |
| 分治算法 | 将一个复杂的问题分解为多个子问题 | 一般 | O(n log n) |

## 常用语言示例

以 C、 Python 、 Go 、 Rust 、 JavaScript 为例

| 类别 | C | Python | Go | Rust | JavaScript |
|---|---|---|---|---|---|
| 数组 | stdlib.h / int a[10]; | typing / list | stdlib / []int | std / Vec<T> | stdlib / Array.from() |
| 链表 | stdlib.h / struct node { int data; struct node *next; }; | collections / collections.deque | stdlib / *linkedlist.List | std / LinkedList<T> | linkedlist / LinkedList() |
| 栈 | stdlib.h / struct stack { int top; int data[10]; }; | collections / collections.deque | stdlib / *stack.Stack | std / Stack<T> | stack / Stack() |
| 队列 | stdlib.h / struct queue { int front; int rear; int data[10]; }; | collections / collections.deque | stdlib / *queue.Queue | std / Queue<T> | queue / Queue() |
| 树 | stdlib.h / struct tree { int data; struct tree *left; struct tree *right; }; | collections / collections.defaultdict | stdlib / *tree.Tree | std / Tree<T> | tree / Tree() |
| 图 | stdlib.h / struct graph { int vertex_num; int edge_num; struct edge *edges; }; | networkx / import networkx as nx | stdlib / *graph.Graph | std / Graph<T> | graph / import graphlib as gl |
| 排序 | stdlib.h / qsort(arr, n, sizeof(int), cmp); | typing / sorted() | sort / sort.Slice() | std / sort::sort() | stdlib / Array.sort() |
| 查找 | stdlib.h / binary_search(arr, n, x); | typing / bisect.bisect_left() | sort / sort.Search() | std / std::search() | stdlib / Array.find() |
| 图算法 | stdlib.h / dfs(graph, start_vertex); | networkx / nx.dfs(graph, start_vertex) | graph / graph.DFS() | std / graph::dfs() | graph / gl.dfs(graph, start_vertex) |
| 动态规划 | stdlib.h / dp[n] = max(dp[n-1], dp[n-2]); | tabulation / import tabulation as tb | std / dp[n] = max(dp[n-1], dp[n-2]); | std / dp[n] = max(dp[n-1], dp[n-2]); | std / dp[n] = max(dp[n-1], dp[n-2]); |
| 分治算法 | stdlib.h / merge_sort(arr, start, end); | divide_and_conquer / import divide_and_conquer as dc | sort / sort.Slice() | std / sort::sort() | stdlib / Array.sort() |

说明

表格中标记为 stdlib.h 的表示标准库头文件，需要包含到程序中。
表格中标记为 import 的表示第三方库，需要先安装。
表格中标记为 typing 的表示 Python 的类型注解，可以不用。

# 操作系统

操作系统是控制计算机硬件和软件的软件。它为应用程序提供了一个抽象的平台，让应用程序可以不必直接与硬件交互。

一个操作系统内核最核心的部分是：

* 进程管理：负责创建、调度和终止进程。
* 内存管理：负责分配和回收内存。
* 设备驱动：负责管理设备硬件。
* 文件系统：负责存储和管理文件。

操作系统内核为运行在它之上的应用提供了以下封装：

* 虚拟内存：应用程序可以使用虚拟内存，而不用担心实际内存的大小。
* 进程间通信：应用程序可以通过各种方式进行通信，例如消息传递、共享内存和管道。
* 文件系统：应用程序可以访问文件系统中的文件。
* 设备驱动：应用程序可以通过操作系统内核访问设备硬件。

## 内核态和用户态

内核态和用户态是操作系统中两个不同的运行模式。内核态是操作系统内核运行的模式，用户态是应用程序运行的模式。

在内核态下，应用程序可以直接访问硬件资源，而不需要经过操作系统的检查。在用户态下，应用程序只能访问操作系统提供的接口。

内核态和用户态之间的切换是由操作系统来控制的。当应用程序需要访问硬件资源时，它会进入内核态。当应用程序完成对硬件资源的访问后，它会回到用户态。

内核态和用户态的区别如下：

特征	内核态	用户态
权限	最高权限	受限权限
可访问资源	所有资源	操作系统提供的资源
代码执行	直接执行	通过系统调用执行
应用程序	操作系统内核	用户应用程序
内核态和用户态的区分是为了保护操作系统和应用程序的安全。在内核态下，应用程序可以直接访问硬件资源，这可能会导致系统崩溃或数据损坏。为了防止这种情况发生，操作系统将内核态和用户态进行了隔离。

## 应用软件开发相关的操作系统基础

### 内存管理
堆：堆是动态内存分配区域，程序可以根据需要在堆中分配内存，并在不需要时释放内存。堆的特点是分配和释放内存的效率高，但不支持内存碎片整理。
栈：栈是程序运行时使用的内存区域，用于存储函数调用时的参数、局部变量等。栈的特点是分配和释放内存的效率高，但支持内存碎片整理。
虚拟内存：虚拟内存是操作系统为每个进程提供的逻辑内存空间，可以大于物理内存的大小。虚拟内存的特点是可以提高程序运行效率，但需要使用页表来管理虚拟内存和物理内存之间的映射关系。
buffer/cache：buffer/cache是操作系统用于缓存数据的区域，可以提高数据访问的效率。buffer/cache的特点是可以减少数据访问的次数，但需要占用系统内存。

### 并发

进程，线程，协程
进程：进程是操作系统中资源分配的最小单位，每个进程都有自己的独立的内存空间、代码空间、数据空间、堆栈空间等。进程的特点是独立性强，但切换效率低。
线程：线程是进程内的一个执行实体，每个线程都有自己的堆栈空间，但共享进程的内存空间、代码空间等。线程的特点是切换效率高，但独立性弱。
协程：协程是轻量级的线程，每个协程都有自己的堆栈空间和局部变量，但共享进程的内存空间、代码空间等。协程的特点是切换效率高，且可以实现并发执行。
这些知识对于应用软件开发具有重要意义，可以帮助开发人员更好地理解操作系统的工作原理，并在开发过程中合理使用操作系统提供的资源。

以下是一些应用软件开发中常见的操作系统知识点：

进程间通信：进程间通信（IPC）是指两个或多个进程之间相互发送数据或信号的过程。常见的IPC方式包括管道、消息队列、共享内存等。
多线程编程：多线程编程是指在一个进程中同时运行多个线程的过程。多线程编程可以提高程序的并发性和响应速度。
虚拟内存：虚拟内存可以帮助应用程序突破物理内存的限制，提高程序的运行效率。
缓存：缓存可以提高数据访问的效率，减少数据访问的次数。
掌握这些知识点可以帮助开发人员提高应用软件的性能和可靠性。

### IO

IO 模型：IO 模型是指操作系统在处理 IO 操作时所采用的策略。常见的 IO 模型包括：


* 同步 IO：同步 IO 是指应用程序在发起 IO 操作后，会一直等待 IO 操作完成才能继续执行。同步 IO 的特点是简单易用，但会导致应用程序的响应速度变慢。

异步 IO：异步 IO 是指应用程序在发起 IO 操作后，可以立即继续执行其他任务，而 IO 操作将在后台完成。异步 IO 的特点是可以提高应用程序的响应速度，但需要开发人员编写复杂的代码来处理 IO 完成后的回调。


阻塞 IO：阻塞 IO 是指当应用程序发起 IO 操作后，如果 IO 操作未完成，则应用程序将被阻塞，直到 IO 操作完成后才能继续执行。
非阻塞 IO：非阻塞 IO 是指当应用程序发起 IO 操作后，如果 IO 操作未完成，则应用程序不会被阻塞，而是立即返回一个状态值，表示 IO 操作是否完成。
IO 多路复用：IO 多路复用是指操作系统可以同时监视多个 IO 操作的状态，当某个 IO 操作完成后，操作系统会通知应用程序。
异步 IO：异步 IO 是指应用程序在发起 IO 操作后，可以立即继续执行其他任务，而 IO 操作将在后台完成。
IO 优化：IO 优化是指提高 IO 操作的性能。常见的 IO 优化方法包括：

使用缓存：缓存可以提高数据访问的效率，减少数据访问的次数。
使用多线程：多线程可以同时执行多个 IO 操作，提高 IO 操作的并发性。
使用异步 IO：异步 IO 可以提高应用程序的响应速度，从而间接提高 IO 操作的性能。
掌握操作系统 IO 相关的知识可以帮助开发人员提高应用软件的性能和可靠性。


select

select 是 Linux 系统中提供的一种 IO 多路复用机制，它可以同时监视多个 IO 操作的状态。select 的实现原理是操作系统维护一个描述符集合，应用程序将要监视的 IO 操作的描述符加入到描述符集合中。操作系统会定期检查描述符集合，如果某个描述符的状态发生变化，则操作系统会通知应用程序。

select 的特点是简单易用，但效率不高。select 需要操作系统在每次检查描述符集合时都遍历整个描述符集合，因此对于描述符数量较多的系统，select 的效率会受到影响。

epoll

epoll 是 Linux 系统中提供的一种高性能 IO 多路复用机制，它是 select 的升级版本。epoll 的实现原理是操作系统维护一个事件表，应用程序将要监视的 IO 操作的描述符加入到事件表中。操作系统会将发生变化的 IO 操作的描述符添加到一个事件列表中，应用程序可以通过轮询事件列表来获取发生变化的 IO 操作。

epoll 的特点是效率高，但使用起来比 select 复杂。epoll 不需要操作系统在每次检查事件表时都遍历整个事件表，因此对于描述符数量较多的系统，epoll 的效率会比 select 高。

select 和 epoll 的区别

特性	select	epoll
实现原理	遍历描述符集合	查询事件表
效率	低	高
使用复杂度	简单	复杂
适用场景	描述符数量较少	描述符数量较多
select 和 epoll 在软件开发中的应用

select 和 epoll 在软件开发中可以用于处理网络 IO 和文件 IO 等。在网络 IO 中，可以使用 select 或 epoll 来监听多个 socket 的状态，以便及时处理网络事件。在文件 IO 中，可以使用 select 或 epoll 来监听多个文件的状态，以便及时处理文件事件。

select 和 epoll 的性能对比

select 和 epoll 的性能对比可以根据描述符数量来进行分析。对于描述符数量较少的系统，select 的性能与 epoll 的性能差别不大。对于描述符数量较多的系统，epoll 的性能明显优于 select。

以下是 select 和 epoll 的性能对比图表：

描述符数量 | select 时间 | epoll 时间
---|---|---|
10 | 1ms | 1ms
100 | 10ms | 1ms
1000 | 100ms | 1ms

select 和 epoll 都是 Linux 系统中提供的 IO 多路复用机制，它们各有优缺点。select 简单易用，但效率不高；epoll 效率高，但使用起来比 select 复杂。在软件开发中，可以根据实际情况选择合适的 IO 多路复用机制。


| 类别 | C | Python | Go | Rust | JavaScript |
|---|---|---|---|---|---|
| 进程 | fork | multiprocessing / multiprocessing.Process() | os / os.Fork() | std::process::Fork() | child_process / child_process.fork() |
| 线程 | pthread_create | threading / threading.Thread() | sync / sync.NewThread() | std::thread::spawn() | threads / threads.spawn() |
| 协程 | goroutine | asyncio / asyncio.get_event_loop().run_until_complete() | go / go func() | std::future::spawn() | async / async function() |
| 消息 | queue | queue / queue.Queue() | sync / sync.NewWaitGroup() | std::sync::mpsc::channel() | queue / queue() |
| 共享内存 | shmget | multiprocessing / multiprocessing.shared_memory.SharedMemory() | sync / sync.Map() | std::sync::mpsc::shared_queue() | shared / shared() |
| 管道 | pipe | multiprocessing / multiprocessing.Pipe() | os / os.Pipe() | std::os::unix::net::pipe() | stream / stream() |
| 同步IO | read | io / io.open() | io / io.Read() | std::io::Read() | fs / fs.readFile() |
| 异步IO | asyncio.open | asyncio / asyncio.open() | io / io.Read() | std::io::Read() | fs / fs.readFile() |
| 多路复用 | select / select / select / std::net::poll() / net / net.select() | select / select / epoll.epoll() / std::net::epoll() / net / net.epoll() |
| 高性能多路复用 | epoll / epoll / epoll / std::net::epoll() / net / net.epoll() | epoll / epoll / epoll / std::net::epoll() / net / net.epoll() |

**说明**

* 表格中标记为 stdlib.h 的表示标准库头文件，需要包含到程序中。
* 表格中标记为 import 的表示第三方库，需要先安装。
* 表格中标记为 typing 的表示 Python 的类型注解，可以不用。

**附加说明**

* `select()` 和 `epoll()` 是两种不同的多路复用方式，`select()` 是传统的多路复用方式，效率较低；`epoll()` 是高性能的多路复用方式，效率较高。
* 表格中 `select()` 和 `epoll()` 的语法分别使用了两种展示方式，一种是使用 `:` 来分隔参数，另一种是使用 `/` 来分隔参数。这两种方式都是正确的，可以根据自己的喜好选择


