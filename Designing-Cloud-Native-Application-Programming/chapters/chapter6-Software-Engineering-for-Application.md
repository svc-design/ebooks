# 应用软件的工程化

应用软件的功能需求、非功能需求和工程化问题是应用软件开发中不可或缺的部分。功能需求是软件必须实现的功能，非功能需求是软件必须满足的属性，工程化问题是软件开发过程中遇到的技术问题。

## 功能需求

功能需求是软件必须实现的功能，是软件开发的起点。功能需求可以分为两类：基本功能需求和附加功能需求。

- **基本功能需求**是软件必须实现的最基本的功能，是软件能够满足用户需求和业务要求的基础。
- **附加功能需求**是软件可以选择实现的功能，可以提升软件的用户体验和可用性。

## 非功能需求

非功能需求是软件必须满足的属性，包括性能需求、安全需求、可靠性需求、可扩展性需求和可维护性需求。

- **性能需求**是软件必须满足的性能指标，如响应时间、吞吐量等。
- **安全需求**是软件必须满足的安全性要求，如数据安全、系统安全等。
- **可靠性需求**是软件必须满足的可靠性要求，如容错性、可恢复性等。
- **可扩展性需求**是软件必须满足的可扩展性要求，如支持用户规模的增长等。
- **可维护性需求**是软件必须满足的可维护性要求，如易于理解、维护等。

## 工程化问题

工程化问题是软件开发过程中遇到的技术问题，包括软件设计问题、软件实现问题和软件部署问题。

- **软件设计问题**是软件的架构设计、算法设计等。
- **软件实现问题**是软件的编程、测试等。
- **软件部署问题**是软件的部署、运维等。

## 工作量占比

功能需求、非功能需求和工程化问题是应用软件开发中不可或缺的部分。功能需求是软件开发的起点，非功能需求是功能需求的延伸，工程化问题是满足功能需求和非功能需求的手段。在应用软件开发过程中，需要充分考虑这三方面的因素，才能开发出满足用户需求、符合业务要求、可靠安全、易于维护的软件，根据历史的统计经验，各自的占比参考如下：

| 名称 | 定义 | 关联关系 | 工作量占比 |
|:----|:----|:----|:----|
| 功能需求 | 软件必须实现的功能 | 非功能需求是功能需求的延伸 | 50% |
| 非功能需求 | 软件必须满足的属性 | 功能需求是软件开发的起点 | 30% |
| 工程化问题 | 软件开发过程中遇到的技术问题 | 满足功能需求和非功能需求的手段 | 20% |


# 现代化的软件工程

在传统的瀑布模型中，功能需求、非功能需求和工程化问题是分阶段进行的。在需求分析阶段，首先要定义功能需求，然后再定义非功能需求，最后才是工程化问题。在开发阶段，先是设计软件，然后是实现软件，最后是部署软件。这种开发模式的缺点是，在需求分析阶段，很难准确预测软件的非功能需求和工程化问题，这可能会导致软件在开发完成后无法满足用户需求或业务要求。

敏捷开发是一种迭代的开发模式，它将功能需求、非功能需求和工程化问题融入到开发过程中。在敏捷开发中，软件开发团队会在短时间内（通常是两周）交付一个可运行的软件版本，然后根据用户反馈进行迭代开发。这种开发模式的优点是，可以更灵活地满足用户需求和业务要求，同时也能提高软件的可靠性和可维护性。

DevOps 是一种软件开发和运维的协同方法论，它将软件开发和运维融为一体。在 Devops 中，软件开发团队和运维团队会紧密合作，共同确保软件的质量和可靠性。DevOps 可以帮助软件开发团队更好地满足用户需求和业务要求，同时也能提高软件的可靠性和可维护性。

| 内容 | 瀑布模型 | 敏捷开发 | DevOps |
|:----|:----|:----|:----|
| 优点 | 开发过程清晰、可控，易于管理和跟踪，适合大型、复杂的软件开发项目 | 灵活，适应变化的需求，开发周期短，成本低，有利于团队协作 | 提高软件质量和可靠性，缩短软件交付周期，降低软件开发成本 |
| 缺点 | 不灵活，难以满足变化的需求，开发周期长，成本高，不利于团队协作 | 开发过程不够清晰、可控，难以管理和跟踪，不适合大型、复杂的软件开发项目 | 需要团队的协作和配合，需要一定的技术和经验 |
| 功能需求 | 软件必须实现的功能 | 软件必须满足的属性 | 软件开发过程中遇到的技术问题 |
| 建议 | 在需求分析阶段，要充分考虑用户需求和业务要求，并尽可能准确地定义功能需求和非功能需求 | 在开发过程中，要采用迭代开发的方式，并根据用户反馈进行调整 | 要采用 Devops 的方法论，将软件开发和运维融为一体 |


瀑布模型和敏捷开发是两种截然不同的开发模式，各有优缺点。瀑布模型适合大型、复杂的软件开发项目，而敏捷开发适合小型、快速迭代的软件开发项目。Devops 是一种方法论，可以帮助软件开发团队更好地满足用户需求和业务要求，同时也能提高软件的可靠性和可维护性。在实际的软件开发中，可以根据项目的特点选择合适的开发模式和方法论.

软件工程化的重要性可以从以下几个方面概述：

- 标准化：通过统一的标准和流程，可以提高软件开发和运维的效率和可靠性。例如，Devops 倡导使用统一的代码库、版本控制系统、部署工具等，可以减少重复工作，提高开发和运维人员的协作效率。
- 流程化：通过建立完善的开发和运维流程，可以确保软件的质量和可靠性。例如，Devops 倡导采用持续集成/持续交付 (CI/CD) 模式，可以快速发现和修复软件中的缺陷。
- 自动化：通过自动化软件开发和运维的各个环节，可以提高效率和可靠性。例如，Devops 倡导采用自动化测试、自动化部署等工具和技术，可以减少人为错误，提高软件的质量和可靠性。

高效的软件工程化可以帮助开发团队在以下方面取得收益：

- 提高软件质量和可靠性：通过标准化、流程化和自动化，可以减少软件开发过程中的错误和缺陷，提高软件的质量和可靠性。
- 缩短软件交付周期：通过 CI/CD 模式，可以快速将软件从开发阶段交付到生产环境，\* 缩短软件交付周期。
- 降低软件开发成本：通过自动化，可以减少人力成本，降低软件开发成本。
- 提高软件开发和运维团队的协作效率：Devops 通过统一的标准和流程，可以促进软件开发和运维团队的协作，提高效率。

软件工程发展的趋势，可以帮助软件开发团队提高软件的质量、可靠性、交付速度和成本效益。以下表格是列举了不同阶段可以使用到的工具：

| 阶段 | 工具类型 | 工具 | 功能 |
|:----|:----|:----|:----|
| 需求分析 | 用户需求收集 | 问卷调查、访谈、用户反馈等 | 收集用户需求 |
| 需求分析 | 需求分析 | 需求文档管理工具、需求分析模型工具等 | 分析用户需求，生成需求文档，识别潜在的风险和问题 |
| 设计 | 软件设计 | UML 建模工具、架构设计工具等 | 生成设计文档，自动生成代码 |
| 编码 | 代码编辑器 | Visual Studio Code、Sublime Text、JetBrains IDE 等 | 编写代码 |
| 测试 | 自动化测试 | Selenium、JUnit、pytest 等 | 自动生成测试用例，分析测试结果 |
| 测试 | 测试辅助工具 | AI 可以自动生成测试用例，并分析测试结果 | ​ |
| 部署 | 持续集成/持续交付 (CI/CD) | Jenkins、Travis CI、GitLab CI/CD 等 | 自动化部署流程，根据需求进行调整 |
| 运维 | 监控工具 | Nagios、Zabbix、Prometheus 等 | 监控软件运行情况 |
| 运维 | 日志分析工具 | ELK、ClickHouse、Fluentd、Logstash 等 | 分析软件运行日志 |
| 运维 | 自动化运维工具 | Ansible、Chef、Puppet 等 | 自动化运维任务 |


随着人工智能（AI）和机器学习（ML）技术的不断发展，软件工程化也在发生一系列变化和改进

1. AI 驱动的软件工程：AI 可以用于辅助生成代码、执行测试软件、识别错误和缺陷、优化软件性能等。
2. ML 驱动的软件工程：例如，ML 可以用于预测软件开发风险、优化软件架构、自动生成文档等。
3. DevOPS的智能化：DevOPS 可以结合 AI 和 ML 技术，例如，可以快速完成自动化 CI/CD 流程、识别软件安全漏洞、分析软件性能等。

随着AIGC技术的成熟，软件工程化的形态，将可能会进一步巨大的改变，例如：

- AIGC 生成代码：AI 可以学习软件开发的模式和规律，从而自动生成代码。这可以提高软件开发的效率，并减少人为错误。
- AIGC 驱动测试：通过对话式的指令，可以自动生成测试用例，生成软件性能分析报告等，
- AIGC 驱动的软件工程全链路自动化：结合LangChain生态链中的，Agent/Tools，甚至可以像人一样听说读写，甚至能高度自动化完地成从用户需求分析、设计、编码、测试、部署到运维中的大部分基础工作。

**相关的部分基于AIGC的软件与服务**

| 软件/服务 | 功能 | 应用场景 |
|:----|:----|:----|
| GitHub Copilot | 代码生成 | 编码 |
| IntelliJ IDEA AI Assistant | 智能提示 | 编码 |
| Google AI Testable AI | 自动化测试 | 测试 |
| Langchain | 自动生成代码、测试软件、识别错误和缺陷、优化软件性能等 | 软件开发的各个环节 |


以下是一些具体的基于AIGC的软件功能介绍：

- GitHub Copilot：GitHub Copilot 是一个代码生成工具，可以帮助软件开发人员自动生成代码。
- IntelliJ IDEA AI Assistant：IntelliJ IDEA AI Assistant 是一个智能提示工具，可以帮助软件开发人员提高编码效率。
- Google AI Testable AI：Google AI Testable AI 是一个自动化测试工具，可以帮助软件开发人员发现和修复软件中的缺陷。
- Langchain：Langchain 是一个人工智能软件工程平台，可以帮助软件开发人员自动生成代码、测试软件、识别错误和缺陷、优化软件性能等。
这些软件与服务可以帮助软件开发人员提高软件开发的效率和质量，并降低软件开发的成本。

# 开发环境

**特别说明**: 

根据 Statcounter 的数据，2023年7月，Linux 服务器操作系统市场占有率为 76.4%，Windows 服务器操作系统市场占有率为 22.3%，除了部分传统企业中还存在一些Windows 服务器操作系统，考虑以下常见问题：
- 开发环境系统与实际线上服务器系统相同的操作系统一致
- 避免开发环境编码和实际线上系统编码不一致引发的问题
-  以及Windows 作为一个商业操作系统，在开发环境方面存在以下缺点：系统封闭，安全性较低；命令行工具功能有限，不易管理。虚拟化/容器化运行环境支持有限等问题。因此，不推荐使用 Windows 作为开发环境。如果需要在 Windows 下作为开发调试环境，可以使用 WSL（Windows Subsystem for Linux）来替代，如果条件具备，更推荐使用Linux/MacOS作为开发环境。在 C、Rust、Go、Python、JavaScript (前端Vue3/后端Nodejs) 开发环境设置步骤均以 Linux（Ubuntu/Fedora）和 MacOS 系统为开发环境为参考。

## C 语言

C 语言在 Linux（Ubuntu/Fedora）和 MacOS 下的开发环境设置步骤：

- Ubuntu/Linux  安装GCC编译器：
在终端中，更新系统软件包列表：sudo apt update && sudo apt install gcc
- Fedora/Linux  安装GCC编译器：
在终端中，更新系统软件包列表：sudo dnf update && sudo dnf install gcc
- MacOS 安装GCC编译器：
安装 Homebrew: 
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
在终端中，更新系统软件包列表：brew update && brew install gcc
- 验证GCC编辑器：
  * 创建一个 C 语言程序源码：hello.c

```C
#include <stdio.h>
int main() {
  printf("Hello, world!\n");
  return 0;
}
```
  - 编译 C 程序：gcc hello.c -o hello
  - 运行 C 程序：./hello 
  - 输出：Hello, world!

额外的开发环境参考：
- 编译工具, C语言的编译工具有很多，开源的主要如下：
    - GCC：GNU Compiler Collection，是C语言、C++语言、Objective-C语言、Fortran语言、Ada语言、Go语言、Rust语言、D语言、Pascal语言等多种语言的编译器集合。
    - Clang：LLVM 项目的编译器，支持 C、C++、Objective-C、Objective-C++、Swift 等语言。
- 测试工具
    - Unittest：C++ 的单元测试框架，也可以用于 C 语言。
    -  Google Test：Google 开发的单元测试框架，支持 C++ 和 C 语言。

- 部署打包工具,C语言的部署打包工具有很多，常用的有：
    - Make：用于构建 Makefile 文件的工具。
    - CMake：用于构建跨平台 Makefile 文件的工具。
    - 
- 安装 IDE：在 Linux 上，可以使用 Visual Code、Atom，在 MacOS 上，可以使用 Xcode。
- 安装调试器：在 Linux 上，可以使用 GDB。在 MacOS 上，可以使用 LLDB。
- 安装代码质量工具：在 Linux 上，可以使用 Clang-Tidy。在 MacOS 上，可以使用 ClangFormat。
- 在 Linux（Ubuntu/Fedora）和 MacOS 上，除了安装 GCC 编译器之外，还需要安装开发库，才能进行更多实际的开发工作, 例如：
  - libstdc++：C++ 标准库
  - libgcc：GCC 编译器依赖的库
  - libpthread：线程库
  - libm：数学库
  - libssl：SSL/TLS 库
  - libcrypto：加密库

以下是各个开发库在 Ubuntu 和 Fedora 上的安装命令：
  - Ubuntu/Linux：sudo apt-get install libstdc++ libgcc libpthread libm libssl libcrypto
  - Fedora/Linux:  dnf install libstdc++ libgcc libpthread libm libssl libcrypto
  - MacOS：brew install libstdc++ libgcc libpthread libm libssl libcrypto


## Vue3

在 Linux（Ubuntu/Fedora）和 MacOS 下的Vue3 开发环境设置步骤：

- Ubuntu/Linux 安装NodeJS，在终端中，更新系统软件包列表：
    sudo apt update
    sudo apt install sudo apt installl nodejs  npm -y 
    npm install -g @vue/cli
- Fedora/Linux 安装NodeJS，在终端中，更新系统软件包列表：
    sudo dnf update
    sudo dnf install sudo dnf installl nodejs npm -y 
    npm install -g @vue/cli
- MacOS 安装NodeJS：
安装 Homebrew: 
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
在终端中，更新系统软件包列表：
  brew update
  brew install nodejs npm
  npm install -g @vue/cli

- 验证 Vue3 开发环境：

```
创建一个 Vue3 项目： vue create my-project
进入项目目录：cd my-project
启动项目：npm run serve
```

额外的开发辅助工具参考：

- VS Code 适用于在 VS Code 中开发 JavaScript 代码的调试
- Chrome DevTools 适用于常规的 JavaScript 开发调试，包括代码高亮、断点设置、变量值查看等。
- Vue DevTools：用于调试 Vue 应用程序的工具。它提供了丰富的调试功能，包括代码高亮、断点设置、变量值查看、堆栈跟踪等
- ESLint：最流行的 JavaScript 代码风格校验工具。它提供了丰富的规则，可以帮助开发者检查代码中的错误和潜在问题。
- Prettier：代码格式化工具。它可以自动格式化代码，使其符合特定的代码风格。
- Husky：Git 钩子工具。它可以用于在提交代码之前自动运行 ESLint 和 Prettier 进行代码风格校验。
- Weex Studio：用于开发基于 Vue3 的 Web 应用和原生应用。
- Android Studio：用于开发 Android 应用。
- Xcode：用于开发 iOS 应用。

## Rust

在 Linux（Ubuntu/Fedora）和 MacOS 下的Rust 开发环境设置步骤：

- Ubuntu/Linux 安装NodeJS，在终端中，更新系统软件包列表：
    安装 Rust: curl [https://sh.rustup.rs](https://sh.rustup.rs) -sSf | sh
    验证 Rust 安装是否成功： rustc --version
- Fedora/Linux 安装NodeJS，在终端中，更新系统软件包列表：
    安装 EPEL 软件源。 sudo yum install epel-release
    安装 Rust: curl [https://sh.rustup.rs](https://sh.rustup.rs) -sSf | sh
    验证 Rust 安装是否成功: rustc --version
- MacOS 安装NodeJS：
    安装 Homebrew: /bin/bash -c "$(curl -fsSL [https://raw.githubusercontent.com/Homebrew/install/master/install.sh](https://raw.githubusercontent.com/Homebrew/install/master/install.sh))"
    使用 Homebrew 安装 Rust: brew install rust
    验证 Rust 安装是否成功: rustc --version

- 验证 Rust 开发环境：
  1. cargo new my-project
  2. 在 src/main.rs 文件中，添加以下代码：
```Rust
fn main() {
    println!("Hello, world!");
}
```
  3. 在终端中，切换到 my-project 文件夹，并执行以下命令来编译该项目：cargo build 将生成一个名为 my-project 的可执行文件。
  4. 运行该项目，请执行以下命令：cargo run 将运行项目的可执行文件，并打印一条消息“Hello, world!” 

额外的开发辅助工具参考：
- Rust-test：Rust 单元测试框架。
- Criterion：Rust 性能测试框架。
- Bencher：Rust 基准测试工具。
- Rust-analyzer-server：Rust 语言服务器的远程版本。
- Rust-analyzer-vscode：Rust 语言服务器的 VS Code 插件
- Rust-doc：Rust 文档生成工具。它可以生成 Rust 程序的文档。
- Cargo-edit：Cargo 包管理器的插件，可以用于快速创建、编辑和管理 Cargo 项目。
- Rustfmt：代码格式化工具。它可以自动格式化代码，使其符合特定的代码风格。
- Clippy：Rust 代码分析工具。它可以帮助开发者发现代码中的错误和潜在问题。
- Rust-analyzer：Rust 语言服务器。它可以提供语法高亮、代码补全、智能提示等功能。

## Go

在 Linux（Ubuntu/Fedora）和 MacOS 下的 Go 开发环境设置步骤如下：

- Ubuntu/Linux 安装 Go
    更新系统软件包列表：sudo apt update
    安装 Go：sudo apt install golang
    配置环境变量：
```
echo "export GOROOT=/usr/lib/go" >> ~/.bashrc
echo "export GOPATH=$HOME/go" >> ~/.bashrc
echo "export PATH=$GOROOT/bin:$PATH" >> ~/.bashrc
```
    加载环境变量：source ~/.bashrc
    验证 Go 版本：go version

- Fedora/Linux 安装 Go
    更新系统软件包列表：sudo dnf update
    安装 Go： sudo dnf install go
    配置环境变量：
````
echo "export GOROOT=/usr/lib/go" >> ~/.bashrc
echo "export GOPATH=$HOME/go" >> ~/.bashrc
echo "export PATH=$GOROOT/bin:$PATH" >> ~/.bashrc
```
  加载环境变量：source ~/.bashrc
  验证 Go 版本： go version

- MacOS 安装 Go
    安装 Homebrew：/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
    使用 Homebrew 安装 Go：brew install go
    验证 Go 版本： go version

- 验证 Go 开发环境
main.go 文件是 Go 程序的入口点，创建 main.go：

```Go
package main

import "fmt"

func main() {
    fmt.Println("Hello, world!")
}
```
使用 go build 和 go run 命令分别编译和运行 Go 程序：
编译 Go 程序: go build -o helloworld
运行 Go 程序: ./helloworld 终端会返回 Hello, world!

- 额外的开发辅助工具参考
  - GoLand：一个由 JetBrains 开发的基于 IntelliJ IDEA 的 IDE，专为 Go 语言开发而设计。
  - Visual Code：一个由 Microsoft 开发的开源 IDE，支持多种编程语言，包括 Go。
  - GoEdit：一个由 Andrew Gerrand 开发的基于 Vim 的 IDE，专为 Go 语言开发而设计。

** 注意事项 **
- 在 Ubuntu 和 Fedora 中，Go 的安装包默认安装在 /usr/lib/go 目录中。
- 在 MacOS 中，Go 的安装包默认安装在 /usr/local/opt/go 目录中。
- 可以使用 go env 命令查看 Go 的环境变量。

## Python

在 Linux（Ubuntu/Fedora）和 MacOS 下的 Python 开发环境设置步骤

- Ubuntu/Linux 安装 Python
    在终端中，更新系统软件包列表：sudo apt update
    安装 Python：sudo apt install python3
- Fedora/Linux 安装 Python
    在终端中，更新系统软件包列表：sudo dnf update 
    安装 Python：sudo dnf install python3
- MacOS 安装 Python
    在终端中，安装 Homebrew：/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
    使用 Homebrew 安装 Python：brew install python

- 验证 Python 开发环境

在终端中，创建一个简单的 Python 脚本：保存为 main.py
```
def greet(name):
    print(f"Hello, {name}!")

if __name__ == "__main__":
    greet("Bard")
```

在终端中，运行脚本： python main.py
如果脚本成功运行，将会输出以下内容：Hello, Bard!

- 额外的开发辅助工具参考
  - IDE： PyCharm、Visual Studio Code、IDLE
  - 代码库管理： Git、GitHub
  - 测试工具： unittest、pytest
  - 文档生成工具： Sphinx
  - 部署工具： Docker、WSGI

- 额外说明
    - Python 版本： 建议使用最新的 Python 3.x 版本。
    - 默认解释器： 在 Ubuntu 和 Fedora 中，Python 3 默认是默认解释器。如果您的系统安装了多个 Python 版本，可以使用以下命令设置默认解释器：sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 1
    - 开发环境配置： 可以根据自己的需要配置 Python 开发环境，例如安装第三方库、配置 IDE 等

# DevOPS 实践参考

推荐使用 git 作为代码仓库版本控制的理由如下：

- 协作：Git 支持多用户协作，可以方便多个开发人员同时开发同一项目。
- 版本控制：Git 是目前最流行的版本控制系统，具有强大的版本管理功能。
- 可扩展性：Git 是开源软件，具有强大的可扩展性，可以根据需要添加新的功能和特性。

GitHub Actions 是 GitHub 提供的持续集成/持续交付 (CI/CD) 服务，可以帮助开发人员自动化代码构建、测试和部署过程。GitHub Actions 具有以下优势：

- 免费使用：GitHub Actions 是 GitHub 提供的免费服务，个人用户可以无限制地使用。
- 易于使用：GitHub Actions 使用 YAML 语言编写，语法简单，易于学习和使用。
- 可扩展性强：GitHub Actions 支持各种 CI/CD 任务，可以根据需要进行扩展和定制。
- 与 GitHub 集成：GitHub Actions 与 GitHub 深度集成，可以利用 GitHub 的众多功能，例如代码管理、版本控制、协作等。
- 持续集成 (CI)：GitHub Actions 可以自动构建代码，并使用单元测试和集成测试来验证代码质量。
- 持续交付 (CD)：GitHub Actions 可以自动将代码部署到本地、开发环境、测试环境或生产环境。

其他可选的有 Gitlab 以及国内的 CI/CD 服务：腾讯云CodeBuild、阿里云效、华为云 CodeBuild，可以根据需要选择。

除了上述工具之外，软件项目开发还可以使用其他一些工具，例如：

- 项目管理工具：Jira、Trello 等。
- 文档管理工具：Confluence、Wiki 等。
- 协作工具：Slack、Zoom 等。

 **额外说明**
如果是大陆区域使用Github因为GFW策略等原因，访问速度会比较慢，建议使用Xtls等开源项目加速器改善

## C 语言项目

- C语言项目开发的标准参考目录结构如下：

```
├── bin
│   ├── main
│   │   └── main
│   └── test
│       └── test
├── doc
│   ├── design
│   │   └── design.md
│   ├── README.md
│   └── requirements.txt
├── include
│   └── header.h
├── lib
│   └── lib.a
├── src
│   ├── main.c
│   └── test.c
├── Makefile
└── Dockerfile
```

说明：

- bin 目录用于存放可执行文件。
- doc 目录用于存放文档，包括设计文档、README 文件、需求文档等。
- include 目录用于存放头文件。
- lib 目录用于存放库文件。
- src 目录用于存放源文件。
- Makefile 用于编译、测试和部署项目。
- Dockerfile 用于构建容器镜像

- 基于 github/workflows 的自动化

使用github/workflows 提供一个支持本地系统构建和基于Dockerfile 多阶段构建的代码示例？

以下是一个支持本地系统构建和基于 Dockerfile 多阶段构建的 C 语言项目的 Github Actions 示例：

YAML

name: C 语言项目构建

on:

  push:

```
branches:
```

```
  - main
```

jobs:

  build:

```
runs-on: ubuntu-latest
```

```
steps:
```

```
  - uses: actions/checkout@v2
```

```
  - name: 安装依赖
    run: |
      sudo apt update
      sudo apt install gcc -y
```

```
  - name: 编译
    run: |
      gcc -o main main.c
```

  docker:

```
runs-on: ubuntu-latest
```

```
steps:
```

```
  - uses: actions/checkout@v2
```

```
  - name: 构建 Dockerfile
    run: |
      docker build -t c-project .
```

```
  - name: 运行测试
    run: |
      docker run c-project
```

请谨慎使用代码。了解详情

该示例包含两个 jobs：

build job 用于本地系统上的编译。

docker job 用于基于 Dockerfile 的多阶段构建。

build job 首先使用 actions/checkout@v2 动作克隆项目代码。然后，使用 sudo apt install gcc -y 命令安装 GCC 编译器。最后，使用 gcc -o main main.c 命令编译项目。

docker job 首先使用 actions/checkout@v2 动作克隆项目代码。然后，使用 docker build -t c-project . 命令构建 Dockerfile。最后，使用 docker run c-project 命令运行测试。

该示例可以根据需要进行修改。例如，可以添加更多的测试用例或修改 Dockerfile 来构建不同的镜像。

以下是一些可以修改的示例：

```
添加更多的测试用例
YAML
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: 安装依赖
        run: |
          sudo apt update
          sudo apt install gcc -y

      - name: 编译
        run: |
          gcc -o main main.c

      - name: 运行测试
        run: |
          gcc -o test test.c
          ./test
请谨慎使用代码。了解详情
修改 Dockerfile 来构建不同的镜像
YAML
jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: 构建 Dockerfile
        run: |
          docker build -t c-project:latest .

      - name: 构建 Dockerfile 并推送到 Docker Hub
        run: |
          docker build -t your-username/c-project:latest .
          docker push your-username/c-project:latest
请谨慎使用代码。了解详情
希望以上内容对您有所帮助。
```

以下是一个 C Dockerfile 的多阶段构建的示例：

```
代码段
# 基础镜像
FROM debian:latest as builder

# 安装依赖
RUN apt update && apt install -y gcc

# 编译
WORKDIR /app
COPY main.c .
RUN gcc -o main main.c

# 运行环境
FROM scratch

# 复制可执行文件
COPY --from=builder /app/main .

# 启动
CMD ["./main"]
```

请谨慎使用代码。了解详情

该示例包含两个阶段：

builder 阶段用于编译 C 程序。

运行环境 阶段用于运行 C 程序。

builder 阶段首先使用 debian:latest 镜像作为基础镜像。然后，使用 apt update && apt install -y gcc 命令安装 GCC 编译器。最后，使用 gcc -o main main.c 命令编译 C 程序。

运行环境 阶段使用 scratch 镜像作为基础镜像。然后，使用 COPY --from=builder /app/main . 命令复制可执行文件到运行环境中。最后，使用 CMD "./main" 命令启动 C 程序。

该示例可以根据需要进行修改。例如，可以添加更多的依赖或修改编译命令。

以下是一些可以修改的示例：

```
添加更多的依赖
代码段
# 基础镜像
FROM debian:latest as builder

# 安装依赖
RUN apt update && apt install -y gcc
RUN apt install -y libfoo-dev

# 编译
WORKDIR /app
COPY main.c .
RUN gcc -o main main.c -lfoo
请谨慎使用代码。了解详情
修改编译命令
代码段
# 基础镜像
FROM debian:latest as builder

# 安装依赖
RUN apt update && apt install -y gcc

# 编译
WORKDIR /app
COPY main.c .
RUN gcc -o main main.c -O3
```

# Python 语言项目

Python 语言项目开发的标准参考目录结构

Python 语言项目开发的标准参考目录结构如下：

├── bin

│   └── my\_app

├── conf

│   └── config.ini

├── data

│   └── data.csv

├── docs

│   └── README.md

│   └── requirements.txt

├── lib

│   └── my\_module.py

├── main.py

├── tests

│   └── test\_my\_module.py

└── venv

说明：

bin 目录用于存放可执行文件。

conf 目录用于存放配置文件。

data 目录用于存放数据文件。

docs 目录用于存放文档，包括 README 文件、requirements.txt 文件等。

lib 目录用于存放 Python 模块。

main.py 是 Python 项目的主程序。

tests 目录用于存放测试用例。

venv 目录用于存放 Python 虚拟环境。

编译

Python 语言不需要编译，可以直接运行。

测试

Python 语言的测试工具有很多，常用的有：

unittest：Python 的标准测试框架。

pytest：一个功能强大的测试框架。

nose2：一个灵活的测试框架。

部署打包工具

Python 语言的部署打包工具有很多，常用的有：

PyInstaller：用于将 Python 程序打包成独立的可执行文件。

Docker：用于将 Python 程序打包成 Docker 镜像。

Pipenv：用于管理 Python 项目的依赖项。

Github Actions 示例

以下是一个支持本地 Python 程序打包和基于 Dockerfile 多阶段构建的 Github Actions 示例：

```YAML
name: Python 项目构建

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: 安装依赖
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: 打包
        run: |
          python -m build

      - name: 测试
        run: |
          python -m pytest tests

  docker:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: 构建 Dockerfile
        run: |
          docker build -t python-project .

      - name: 运行测试
        run: |
          docker run python-project
```

请谨慎使用代码。了解详情

该示例包含两个 jobs：

build job 用于本地 Python 程序打包。

docker job 用于基于 Dockerfile 的多阶段构建。

build job 首先使用 actions/checkout@v2 动作克隆项目代码。然后，使用 python -m pip install --upgrade pip 命令升级 pip 包管理器。最后，使用 pip install -r requirements.txt 命令安装项目依赖。

build job 然后使用 python -m build 命令打包 Python 程序。

build job 最后使用 python -m pytest tests 命令运行测试。

docker job 首先使用 actions/checkout@v2 动作克隆项目代码。然后，使用 docker build -t python-project . 命令构建 Dockerfile。最后，使用 docker run python-project 命令运行测试。

该示例可以根据需要进行修改。例如，可以添加更多的测试用例或修改 Dockerfile 来构建不同的镜像。

以下是一些可以修改的示例：

添加更多的测试用例

```
YAML
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
```

 Python Dockerfile 的多阶段构建的示例：

```Dockerfile
# 基础镜像
FROM python:3.9-slim as builder

# 安装依赖
RUN pip install --upgrade pip
RUN pip install -r requirements.txt

# 编译
WORKDIR /app
COPY . .
RUN python setup.py build

# 运行环境
FROM python:3.9-slim

# 复制可执行文件
COPY --from=builder /app/dist/my_app /app/my_app

# 启动
CMD ["python", "/app/my_app"]
```

请谨慎使用代码。了解详情

该示例包含两个阶段：

builder 阶段用于编译 Python 程序。

运行环境 阶段用于运行 Python 程序。

builder 阶段首先使用 python:3.9-slim 镜像作为基础镜像。然后，使用 pip install --upgrade pip 命令升级 pip 包管理器。最后，使用 pip install -r requirements.txt 命令安装项目依赖。

builder 阶段然后使用 python setup.py build 命令编译 Python 程序。

运行环境 阶段使用 python:3.9-slim 镜像作为基础镜像。然后，使用 COPY --from=builder /app/dist/my\_app /app/my\_app 命令复制可执行文件到运行环境中。最后，使用 CMD "python", "/app/my\_app" 命令启动 Python 程序。

该示例可以根据需要进行修改。例如，可以添加更多的依赖或修改编译命令。

以下是一些可以修改的示例：

```
添加更多的依赖
Dockerfile
# 基础镜像
FROM python:3.9-slim as builder

# 安装依赖
RUN pip install --upgrade pip
RUN pip install -r requirements.txt
RUN pip install -r requirements-dev.txt
请谨慎使用代码。了解详情
修改编译命令
Dockerfile
# 基础镜像
FROM python:3.9-slim as builder

# 安装依赖
RUN pip install --upgrade pip
RUN pip install -r requirements.txt

# 编译
WORKDIR /app
COPY . .
RUN python setup.py build --wheel
```

# 前端/Vue3 项目

Vue3 项目开发的标准参考目录结构如下：

```
├── public
│   └── index.html
├── src
│   ├── App.vue
│   ├── components
│   │   └── HelloWorld.vue
│   ├── main.js
│   └── router
│       └── index.js
└── package.json
```

说明：

public 目录用于存放静态资源，例如 HTML、CSS、JavaScript 等文件。

src 目录用于存放 Vue3 项目的源代码。

App.vue 是 Vue3 项目的根组件。

components 目录用于存放 Vue3 组件。

main.js 是 Vue3 项目的入口文件。

router 目录用于存放 Vue3 路由配置。

支持本地 Vue3 程序打包和基于 Dockerfile 多阶段构建的 Github Actions 示例如下：

```YAML
name: Vue3 项目构建

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: 安装依赖
        run: |
          yarn install

      - name: 打包
        run: |
          yarn build

      - name: 测试
        run: |
          yarn test

  docker:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: 构建 Dockerfile
        run: |
          docker build -t vue3-project .

      - name: 运行测试
        run: |
          docker run vue3-project
```

请谨慎使用代码。了解详情

该示例包含两个 jobs：

build job 用于本地 Vue3 程序打包。

docker job 用于基于 Dockerfile 多阶段构建。

build job 首先使用 actions/checkout@v2 动作克隆项目代码。然后，使用 yarn install 命令安装项目依赖。最后，使用 yarn build 命令打包 Vue3 程序。

build job 最后使用 yarn test 命令运行测试。

docker job 首先使用 actions/checkout@v2 动作克隆项目代码。然后，使用 docker build -t vue3-project . 命令构建 Dockerfile。最后，使用 docker run vue3-project 命令运行测试。

Vue3 Dockerfile 的多阶段构建的示例如下：

Dockerfile

```
# 基础镜像
FROM node:16-alpine as builder

# 安装依赖
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm install

# 构建
COPY . .
RUN npm run build

# 运行环境
FROM nginx:latest

# 复制可执行文件
COPY --from=builder /app/dist /usr/share/nginx/html

# 启动
CMD ["nginx", "-g", "daemon off;"]
```

请谨慎使用代码。了解详情

该示例包含两个阶段：

builder 阶段用于编译 Vue3 程序。

运行环境 阶段用于运行 Vue3 程序。

builder 阶段首先使用 node:16-alpine 镜像作为基础镜像。然后，使用 WORKDIR /app 命令设置工作目录。最后，使用 npm install 命令安装项目依赖。

builder 阶段然后使用 COPY . . 命令复制项目代码到工作目录。最后，使用 npm run build 命令构建 Vue3 程序。

运行环境 阶段使用 nginx:latest 镜像作为基础镜像。然后，使用 COPY --from=builder /app/dist /usr/share/nginx/html 命令复制可执行文件到运行环境中。最后，使用 CMD "nginx", "-g", "daemon off;" 命令启动 nginx。

# 后端 NodeJS 项目

后端 NodeJS / Express 项目开发的标准参考目录结构

NodeJS 后端项目开发的标准参考目录结构如下：

├── package.json

├── package-lock.json

├── README.md

├── src

│   ├── app.js

│   ├── config

│   │   ├── config.js

│   │   └── database.js

│   ├── models

│   │   └── user.model.js

│   └── routes

│       └── index.js

└── tests

```
└── unit
```

```
    └── user.test.js
```

说明：

package.json 和 package-lock.json 文件用于管理项目的依赖关系。

README.md 文件用于描述项目的相关信息。

src 目录用于存放项目的源代码。

app.js 文件是项目的入口文件，用于启动服务器。

config 目录用于存放项目的配置文件。

models 目录用于存放项目的数据模型。

routes 目录用于存放项目的路由配置。

tests 目录用于存放项目的单元测试。

具体说明如下：

package.json 文件用于指定项目的依赖关系，以及项目的相关信息，例如名称、版本、作者等。

package-lock.json 文件用于记录项目的依赖关系的版本号，用于确保项目的一致性。

README.md 文件用于描述项目的相关信息，例如项目的目的、使用方法等。

src 目录用于存放项目的源代码，包括 app.js 文件、配置文件、数据模型、路由配置等。

app.js 文件是项目的入口文件，用于启动服务器。

config 目录用于存放项目的配置文件，例如数据库配置、环境变量配置等。

models 目录用于存放项目的数据模型，用于描述数据库中的表结构。

routes 目录用于存放项目的路由配置，用于定义 HTTP 请求的路径和处理逻辑。

tests 目录用于存放项目的单元测试，用于验证代码的正确性。

1. 本地 NodeJS 后端程序打包和基于 Dockerfile 多阶段构建的 Github Actions 示例

以下是一个支持本地 NodeJS 后端程序打包和基于 Dockerfile 多阶段构建的 Github Actions 示例：

```YAML
name: Build and Deploy
on:
  push:
    branches:
      - main
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install dependencies
        run: npm install
      - name: Build application
        run: npm run build
      - name: Build Docker image
        run: docker build -t my-app .
      - name: Push Docker image
        run: docker push my-app

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Deploy to Kubernetes
        run: |
          kubectl apply -f deployment.yaml
          kubectl apply -f service.yaml
```

请谨慎使用代码。了解详情

说明：

on 字段用于指定触发 Github Actions 的事件。

jobs 字段用于定义 Github Actions 的流程。

build 作业用于打包 NodeJS 后端程序并构建 Docker 镜像。

deploy 作业用于将 Docker 镜像部署到 Kubernetes 集群。

1. NodeJS 后端 Dockerfile 的多阶段构建的示例

以下是一个 NodeJS 后端 Dockerfile 的多阶段构建示例：

```
代码段
FROM node:16-alpine as build

WORKDIR /app

COPY package.json ./

RUN npm install

COPY . .

RUN npm run build
```

[https://github.com/lujingtao/Vue-and-nodejs-communication](https://github.com/lujingtao/Vue-and-nodejs-communication)

# GO 语言项目

 GO语言 项目开发的标准参考目录结构

 GO语言 标准参考目录结构

以下是一个 GO语言 项目的标准目录结构示例：

my-project

├── cmd

│   └── main

│       └── main.go

├── internal

│   └── config

│       └── config.go

│   └── database

│       └── database.go

│   └── models

│       └── user.go

├── pkg

│   └── utils

│       └── utils.go

└── README.md

在上述示例中:

- cmd 目录是项目的主目录，存放项目的主程序。
- internal 目录存放项目的私有代码，不希望公开的代码可以放在这里。
- pkg 目录存放项目的公共代码，可以被其他项目引用。
- README.md 文件描述项目的相关信息，例如项目的目的、使用方法等。
- go.mod 文件管理项目的依赖关系，包括项目的名称、版本、作者等。
- go.sum 文件记录项目的依赖关系的版本号，用于确保项目的一致性。

 **注意** 

- 该目录结构只是一个推荐，开发者可以根据自己的实际需要进行调整。
- 在使用 go mod 管理依赖关系时，go.mod 文件和 go.sum 文件是必不可少的。
- 本地 GO语言 程序打包和基于 Dockerfile 多阶段构建的 Github Actions 示例

以下是一个支持本地 GO语言 程序打包和基于 Dockerfile 多阶段构建的 Github Actions 示例：

```YAML
name: Build and Deploy
on:
  push:
    branches:
      - main
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install dependencies
        run: go mod download
      - name: Build application
        run: go build -o ./bin/my-app
      - name: Build Docker image
        run: docker build -t my-app .
      - name: Push Docker image
        run: docker push my-app

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Deploy to Kubernetes
        run: |
          kubectl apply -f deployment.yaml
          kubectl apply -f service.yaml
```

请谨慎使用代码。了解详情

1. GO语言 Dockerfile 的多阶段构建的示例

以下是一个 GO语言 Dockerfile 的多阶段构建示例：

```
代码段
FROM golang:1.18-alpine as build

WORKDIR /app

COPY go.mod ./
COPY go.sum ./
RUN go mod download

COPY . .

RUN go build -o ./bin/my-app

FROM alpine:latest

COPY --from=build /app/bin/my-app /app/my-app

CMD ["/app/my-app"]
```

请谨慎使用代码。了解详情

多阶段构建

在上述示例中，使用了多阶段构建来实现 GO语言 程序的打包和部署。第一阶段使用 golang 镜像来打包 GO语言 程序，第二阶段使用 alpine 镜像来将打包后的程序部署到容器中。

## Rust 语言项目

以下是 Rust 语言 项目开发的标准参考目录结构、本地 Rust 语言 程序打包和基于 Dockerfile 多阶段构建的 Github Actions 示例、Rust 语言 Dockerfile 的多阶段构建的示例：

Rust 语言 项目开发的标准参考目录结构

Rust 语言 项目开发的标准参考目录结构如下：

src 目录：存放项目的源代码，包括 main.rs 文件、配置文件、数据模型、路由配置等。

Cargo.toml 文件：管理项目的依赖关系。

README.md 文件：描述项目的相关信息。

说明

src 目录是项目的主目录，存放项目的源代码。

Cargo.toml 文件管理项目的依赖关系，包括项目的名称、版本、作者等。

README.md 文件描述项目的相关信息，例如项目的目的、使用方法等。

示例

以下是一个 Rust 语言 项目的标准目录结构示例：

my-project

├── src

│   └── main.rs

│   └── config.rs

│   └── database.rs

│   └── models.rs

│   └── routes.rs

└── Cargo.toml

└── README.md

在上述示例中，src/main.rs 文件是项目的主程序，Cargo.toml 文件管理项目的依赖关系，README.md 文件描述项目的相关信息。

本地 Rust 语言 程序打包和基于 Dockerfile 多阶段构建的 Github Actions 示例

以下是一个支持本地 Rust 语言 程序打包和基于 Dockerfile 多阶段构建的 Github Actions 示例：

YAML

name: Build and Deploy

on:

  push:

```
branches:
```

```
  - mainjobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install dependencies
        run: cargo install --path .
      - name: Build application
        run: cargo build --release
      - name: Build Docker image
        run: docker build -t my-app .
      - name: Push Docker image
        run: docker push my-app
```

  deploy:

```
needs: build
```

```
runs-on: ubuntu-latest
```

```
steps:
```

```
  - uses: actions/checkout@v2
  - name: Deploy to Kubernetes
    run: |
      kubectl apply -f deployment.yaml
      kubectl apply -f service.yaml请谨慎使用代码。了解详情
Rust 语言 Dockerfile 的多阶段构建的示例
以下是一个 Rust 语言 Dockerfile 的多阶段构建示例：
```

代码段

FROM rust:1.60.0 as build

WORKDIR /app

COPY . .

RUN cargo build --release

FROM alpine:latest

COPY --from=build /app/target/release/my-app /app/my-app

CMD "/app/my-app"

请谨慎使用代码。了解详情

多阶段构建

在上述示例中，使用了多阶段构建来实现 Rust 语言 程序的打包和部署。第一阶段使用 rust 镜像来打包 Rust 语言 程序，第二阶段使用 alpine 镜像来将打包后的程序部署到容器中。

说明

FROM 指令用于指定基础镜像。

WORKDIR 指令用于指定工作目录。

COPY 指令用于将文件或目录复制到镜像中。

RUN 指令用于在镜像中执行命令。

EXPOSE 指令用于指定镜像暴露的端口。

CMD 指令用于指定镜像启动时执行的命令。

vue3

brew install node

npm install @vue/cli

npm init vite@latest

按提示进行操作，然后打开项目

npm install

npm run dev

npm i axios

npm install vue-router@4

npm install pinia

npm init @vitejs/app

npm install @vue/cli-plugin-weex

vue-cli-service build --target=weapp

原生开发工具：

HBuilderX

Android Studio：用于开发 Android 应用。

Xcode：用于开发 iOS 应用。

Weex Studio：用于开发基于 Vue3 的 Web 应用和原生应用。
